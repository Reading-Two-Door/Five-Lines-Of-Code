# 코드 구조 따르기

- 소프트웨어는 현실 세계의 한 측면에 대한 모델이다. 현실의 변화를 포괄하도록 소프트웨어를 조정해야 한다.

## 11.1 범위와 출처에 따른 구조 분류

**매크로 아키텍처**

- 팀 간 구조
- 제품이 무엇이며 다른 코드가 그것과 어떻게 상호작용 하는가
- 외부 API가 어떻게 보여야 하는가, 각 팀이 어떤 데이터를 소유하는지

**마이크로 아키텍처**

- 팀 내 구조
- 팀이 가치를 제공하기 위해 무엇을 할 수 있는지, 어떤 서비스를 사용하는지, 데이터를 어떻게 구성할지, 코드를 어떻게 작성할지

**콘웨이 법칙**

- 조직 구성과 그 조직이 만든 시스템 구조는 닮는 경향이 있다.
- 도메인 전문가의 행위 패턴은 코드에 스며드는 경향이 있다.
- 코드에서 비효율성을 발견하면 전문가가 작업하는 방식이나 프로세스와 같은 다른 곳에서 실제 원인을 발견할 수 있다.

| 구분          | 팀 간 아키텍처                                                                                                                    | 팀 내 아키텍처                                                                                                                            |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| **코드 중심** | • 서비스 간 API 계약<br>• MSA 서비스 경계 설정<br>• 공유 라이브러리 구조<br>• 데이터베이스 샤딩 정책<br>• 분산 트랜잭션 처리 방식 | • 도메인 모델 설계<br>• 레이어 아키텍처 구조<br>• 핵심 비즈니스 로직 배치<br>• 컴포넌트 의존성 관리<br>• 로컬 캐시 전략                   |
| **사람 중심** | • 배포 파이프라인 정책<br>• API 변경 관리 프로세스<br>• 서비스 장애 전파 정책<br>• 팀 간 코드 공유 정책<br>• 성능 모니터링 체계   | • 도메인 용어 정의 프로세스<br>• 도메인 전문가 리뷰 체계<br>• 유비쿼터스 언어 관리<br>• 도메인 지식 공유 방식<br>• 요구사항 정제 프로세스 |

## 11.2 행위를 코드화하는 세 가지 방법

- 제어 흐름
- 데이터 구조
- 데이터 자체

### 11.2.1 제어 흐름에 행위 코드화하기

- 제어 연산자, 메서드 호출, 단순히 열거된 코드의 줄을 통해 행위를 텍스트로 표현한다.
- 메서드 호출과 열거된 코드는 비지역적 구조를 표현할 수 있지만 루프는 지역적으로만 동작가능하다.
  - 루프는 일단 시작되면 그 내부 로직에 따라서만 동작하고, 외부에서 루프의 실행을 직접적으로 조작하거나 제어할 수 없다.
- 제어 연산자와 메서드 호출은 무한 루프가 가능하다.
- 안전성과 작은 변화를 선호하기에 제어 흐름을 사용해 리팩터링하지 않는다.
  - 제어흐름(루프 등)안에 행위를 직접 기술하지말고 행위를 분리(함수 추출)하고 제어흐름에서 분리된 행위(함수)를 실행
- 큰 조정이 필요한 경우 동작을 제어흐름으로 리팩터링 한다음 다시 리팩터링 하는 것이 유용

### 11.2.2 데이터 구조에 행위 코드화하기

- 재귀 데이터 구조는 기존의 변형이 발생하는 지점과 일치하지 않는 한 큰 변경을 수행하기가 더 어렵다. 그러나 작은 변경은 더 쉽고 안전하다.
  - 재귀 데이터 구조에서는 데이터의 구조가 명확하게 정의되어 있어서, 구조를 크게 바꾸려면 전체 데이터 구조를 수정해야 함
  - 하지만 데이터 구조를 변경하지 않고 해당 데이터 구조를 활용하는 쪽에서는 자유롭게 활용이 가능하다.
- 더 많은 타입 안전성과 지역성을 어디 때문
- 클래스로 타입 코드 대체 + 전략 패턴의 도입 케이스

```typescript
// 1. 재귀적 데이터 구조
type TreeNode<T> = {
  value: T;
  left: TreeNode<T> | null;
  right: TreeNode<T> | null;
};

// 2. 제어 흐름 기반 접근
function processTreeWithControl<T>(tree: TreeNode<T>): void {
  const queue: TreeNode<T>[] = [tree];
  while (queue.length > 0) {
    const node = queue.shift()!;
    // 여기서 직접 데이터 조작
    node.value = transform(node.value); // 위험: 직접적인 상태 변경
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }
}

// 3. 재귀 데이터 기반 접근
function transformTree<T>(node: TreeNode<T>, fn: (value: T) => T): TreeNode<T> {
  return {
    value: fn(node.value),
    left: node.left ? transformTree(node.left, fn) : null,
    right: node.right ? transformTree(node.right, fn) : null,
  };
}
```

여기서 "큰 변경이 어렵다"는 것은:

1. 재귀 데이터 구조를 근본적으로 바꾸려면 (예: 이진 트리를 3진 트리로):

```typescript
// 기존 구조와 많이 다른 새로운 형태로 변경하기 어려움
type TernaryNode<T> = {
  value: T;
  left: TernaryNode<T> | null;
  middle: TernaryNode<T> | null;
  right: TernaryNode<T> | null;
};
```

이러한 접근의 장점:

1. 컴파일러가 타입 오류를 미리 잡아줌
2. 각 변형이 명확한 입력과 출력을 가짐
3. 변경의 영향 범위가 명확히 제한됨
4. 변형을 조합하기 쉬움

제어 흐름 방식과 비교하면:

1. 제어 흐름은 상태 변경을 직접 수행하여 부작용이 발생하기 쉬움
2. 변경의 영향 범위를 추적하기 어려움
3. 여러 변경을 조합하기 어려움

이렇게 보면 재귀 데이터 구조가 큰 구조적 변경은 어렵지만, 일반적인 데이터 변형과 같은 작은 변경에서는 더 안전하고 관리하기 쉽다는 것을 알 수 있습니다.

### 11.2.3 데이터에 행위 코드화하기 (????)

- 컴파일러의 사각지대이기에 조심해야 한다.
- 데이터를 검색해서 데이터에서 데이터 구조를 생성하는 도구를 사용하는 것으로 해결가능? (Map 객체 등)

## 11.3 구조 노출을 위한 코드 추가

- 주변에 참고할 코드가 많을수록 이 방향의 코드와 데이터가 많이 있기 때문에 코드가 어떻게 변경될지 알 가능성이 높다.
- 리팩터링은 현재 구조를 강화하고 유사한 변경 사항을 더 잘 수용할 수 있게 한다.
- 기본 구조에 대한 확신이 없다면 리팩터링 노력을 줄이고 정확성에 집중해야 한다.
- 새로운 기능이나 하위 시스템을 구현할 떄는 불확실성이 있기 마련이므로 빠르게 변경할 수 있도록 클래스보다 열거형이나 루프가 나을 수 있다.
- 코드가 성숙해지고 구조가 더 안정되면 코드도 리팩터링을 통해 구조에 맞게 안정돼야 한다.

## 11.4 예측 대신 관찰, 그리고 경험적 기술 허용

- 변경 범위를 예측하려는 시도는 코드베이스에 도움이 되기보다는 손상을 줄 수 있다.
- 일반화된 코드가 사용될지에 관한 확신이 없다면 불필요한 코드와 우발적 복잡성만 더하는 셈이다.

## 11.5 코드를 이해하지 않고도 안전성을 확보하는 방안

- 이미 코드에 있는 구조를 따르고 믿을만한 리팩터링 패턴을 사용하는 한 작업을 위해 코드를 이해할 필요가 없다.
- 인간이 실수를 하기 때문에 까다로울 수 있다. 하지만 보호하기 위한 방안이 있다. 하지만 완전한 것은 없다.

### 11.5.1 테스트를 통한 안전성 확보

- 사람이 테스트하는 것은 엄청난 시간이 소요되며 오류가 발생하기 쉽다.
- 실수가 일어나는 위치나 기대하는 부분들이 테스트되지 않을 수 있음을 주의

### 11.5.2 숙달을 통한 안전성 확보

- 리팩터링 시 실수 가능성을 줄이는 것
- 리팩터링을 작은 단계로 분할
- 반복숙달

### 11.5.3 도구의 지원을 통한 안전성 확보

- IDE 등 도구의 기능을 활용해 인간의 실수를 줄이자

### 11.5.4 공식 인증을 통한 안전성 확보

- 증명보조기를 사용해 프로그램의 논리적인 명제가 올바른지 기계적으로 확인
- 도구의 지원이기에 11.5.3과 유사

### 11.5.5 내결함성을 통한 안전성 확보

- 오류가 발생하더라도 자체 수정하도록 코드를 작성
- 실패 시 자동 롤백
- 기능 전환 시스템이 올바른 응답과 오류를 구별하지 못하는 경우 실패할 수 있다.

## 11.6 활용되지 않은 구조 이용

- 기초가 견고한지, 구조가 지속될 가능성이 있는지를 고려해라
- 도메인은 소프트웨어보다 오래된 경향이 있으므로 더 성숙하고 급격한 변화가 덜 발생한다.
- 소프트웨어에 비하면 우리 프로세스와 팀은 수명이 짧다. 프로세스를 시스템화 했다면 새로운 프로세스를 도입할 때 기존 프로세스 코드를 모두 풀어헤쳐야 한다.

### 11.6.1 추출 및 캡슐화에 공백 활용

- 코드 구조에 따라 빈 줄을 활용해 구조를 표현
- 공백으로 그룹화된 문장들은 메서드 추출 패턴을 고려하자

### 11.6.2 통합에 중복 코드 활용

- 중복된 코드를 **메서드 추출 리팩터링 패턴**을 사용할 수 있다.
- 추출된 메서드가 여러 클래스에 분산되어 있을 경우 **메서드에 데이터 캡슐화**를 사용
- 캡슐화한 클래스들이 유사하거나 중복된 것을 볼 때 **유사클래스 통합 패턴**을 사용
- 문장의 제어 흐름은 유사한데, 문장 자체가 다른 경우에는 **전략 패턴** 사용

### 11.6.3 캡슐화로 공통 접사 활용

- 공통 접사를 사용하지 말것
- 그룹으로 판단할 수 있기때문에 클래스화를 통해 **데이터 캡슐화**를 사용

### 11.6.4 동적 실행으로 런타임 유형 활용

- 새로운 인터페이스를 만들어 대체하기
- 소스를 제어할 수 없다면 코드베이스가 오염되지 않도록 타입 검사를 코드의 가장자리에 위치시켜야 한다.
