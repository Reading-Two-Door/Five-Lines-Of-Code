# 타입 코드 처리하기

## 4.1 간단한 if문 리팩터링

### 4.1.1 규칙: if문에서 else를 사용하지 말 것

- 타입 인지를 검사하지 않는 한 if 문에서 else를 사용하지마라
- if-else가 있는 위치 이후에서는 다른 변형을 도입할 수 없기 때문에 코드의 유연성이 떨어진다.
- 독립된 if문은 검사(check)로 간주하고, if-else 문은 의사결정(decision)으로 간주한다.

`얼리 리턴을 함수화해서 throw를 던질 시 catch를 해야하는 문제가 있는데 이런식으로 코드를 짜나?`

### 4.1.2 규칙 적용

- Input을 enum에서 인터페이스로 교체

### 4.1.3 리팩터링 패턴: 클래스로 타입 코드 대체

- 열거형의 값을 클래스로 변환함으로써 각 값에 속성을 추가하고 특정 값과 관련된 기능을 특성에 맞게 만들 수 있다.
- 열거형에 새 값을 추가하는 것은 수많은 파일에 걸쳐 사용되는 로직들을 확인해야 하는 반면, 인터페이스를 통해 구현한 새로운 클래스 추가는 추가된 메서드의 구현만 하면된다.

1. 클래스의 메서드로 조건 체크 로직 추가
2. 기존 enum 변수명을 변경해 의도적으로 에러를 발생
3. 기존 if 문의 내부의 조건문을 클래스의 메서드로 대체

### 4.1.4 클래스로 코드 이관하기

- 클래스 내부에서 메서드 동작을 정의함으로써 조건문 제거

### 4.1.5 리팩터링 패턴: 클래스로의 코드 이관

1. 원래 함수를 복사하여 클래스로 붙여넣기
2. 메서드에 맞게 네이밍 수정
3. 새로운 메서드 점검
4. 함수의 본문을 새로운 메서드 호출로 변경

### 4.1.6 불필요한 메서드 인라인화

- 메서드를 인라인화해서 사용
- 메서드 추출과 정반대

### 4.1.7 리팩터링 패턴: 메서드의 인라인화

- 가독성에 도움이 되지 않는 메서드를 제거

## 4.2 긴 if 문의 리팩터링

### 4.2.1 일반성 제거

- 일반성은 유연성이 떨어지고 변경하기 어렵게 만든다.
- 일반화를 줄이고 특정화한 버전의 함수를 도입하는 과정을 메서드 전문화

### 4.2.2 리팩터링 패턴: 메서드 전문화

- 일반화하고 재사용하면 책임이 흐려지고 다양한 위치에서 코드를 호출할 수 있기 때문에 문제가 될 수 있다.
- 전문화된 메서드는 더 적은 위치에서 호출되어 필요성이 없어지면 더 빠르게 제거할 수 있다.

### 4.2.3 switch가 허용되는 유일한 경우

- 기존 이중배열로 구성된 map 배열을 transform하는 함수에서 switch 케이스로 class생성

### 4.2.4 규칙: switch를 사용하지 말 것

- default 케이스가 없고 모든 case에 반환 값이 있는 경우가 아니라면 사용하지마라
- 타입스크립트에서 switch문과 enum을 함께 사용 시 enum의 열거값을 모두 사용하지 않을 경우 Type error를 일으킨다.

`컨텍스트에 초점을 맞춘다는 것은 데이터에서 불변속성을 더 멀리 위치시켜 불변속성을 전역화 하는 것?` 불변속성을 타입/인터페이스 레벨로 전역화

### 4.2.5 if 제거하기

- 클래스로 코드 이관 패턴을 통해 제거
- 이후 메서드의 인라인화로 사용 후 기존 함수 제거
