# 타입 코드 처리하기

## 4.1 간단한 if문 리팩터링

### 4.1.1 규칙: if문에서 else를 사용하지 말 것

- 타입 인지를 검사하지 않는 한 if 문에서 else를 사용하지마라
- if-else가 있는 위치 이후에서는 다른 변형을 도입할 수 없기 때문에 코드의 유연성이 떨어진다.
- 독립된 if문은 검사(check)로 간주하고, if-else 문은 의사결정(decision)으로 간주한다.

`얼리 리턴을 함수화해서 throw를 던질 시 catch를 해야하는 문제가 있는데 이런식으로 코드를 짜나?`

### 4.1.2 규칙 적용

- Input을 enum에서 인터페이스로 교체

### 4.1.3 리팩터링 패턴: 클래스로 타입 코드 대체

- 열거형의 값을 클래스로 변환함으로써 각 값에 속성을 추가하고 특정 값과 관련된 기능을 특성에 맞게 만들 수 있다.
- 열거형에 새 값을 추가하는 것은 수많은 파일에 걸쳐 사용되는 로직들을 확인해야 하는 반면, 인터페이스를 통해 구현한 새로운 클래스 추가는 추가된 메서드의 구현만 하면된다.

1. 클래스의 메서드로 조건 체크 로직 추가
2. 기존 enum 변수명을 변경해 의도적으로 에러를 발생
3. 기존 if 문의 내부의 조건문을 클래스의 메서드로 대체

### 4.1.4 클래스로 코드 이관하기

- 클래스 내부에서 메서드 동작을 정의함으로써 조건문 제거

### 4.1.5 리팩터링 패턴: 클래스로의 코드 이관

1. 원래 함수를 복사하여 클래스로 붙여넣기
2. 메서드에 맞게 네이밍 수정
3. 새로운 메서드 점검
4. 함수의 본문을 새로운 메서드 호출로 변경

### 4.1.6 불필요한 메서드 인라인화

- 메서드를 인라인화해서 사용
- 메서드 추출과 정반대

### 4.1.7 리팩터링 패턴: 메서드의 인라인화

- 가독성에 도움이 되지 않는 메서드를 제거
