# 컴파일러와의 협업

## 7.1 컴파일러에 대해 알아보기

- 컴파일러는 프로그램이다. 따라서 일관성 같은 특정 작업에 능숙하다.
- 컴파일러의 목표는 소스 프로그램과 도일한 다른 언어로 된 프로그램을 생성하는 것
- 최신 컴파일러들은 런타임 중에 특정 오류가 발생할 수 있는지도 확인한다.

### 7.1.1 약점: 정지 문제는 컴파일 시 알 수 있는 것을 제한한다.

- 정지 문제 - 런타임 동안 어떤 일이 일어날지 정확히 말할 수 없는 이유로 프로그램을 실행하지 않고는 프로그램이 어떻게 동작할 지 알 수 없다.
- 보수적 분석 - 프로그램이 안전하다고 보장할 수 없는 경우 컴파일러는 프로그램을 허용하지 않는다.

### 7.1.2 장점: 도달성 검증은 메서드의 반환을 보장한다.

- 보수적인 분석 중 하나는 메서드가 모든 경우에서 반환되는지 확인하는 것
- 완전 검사 - 열거형의 모든 case를 포함하고 있는지 체크하는 것?

### 7.1.3 장점: 확정 할당은 초기화되지 않은 변수에 대한 접근을 막는다.

- 컴파일러는 변수가 사용되기 전에 변수에 값이 확실히 할당되었는지 여부 체크가 가능
- 지역변수, 특히 if문을 사용해서 지역변수를 초기화하려는 경우에 적용
- 확정 할당 분석이 적용되는 읽기전용 필드를 사용해서 컴파일러에게 알릴 수 있다.

### 7.1.4 장점: 접근 제어로 데이터 캡슐화를 지원한다.

- 컴파일러는 데이터를 캡슐화할 때 사용하는 접근 제어에도 탁월하다.
- 멤버를 프라이빗으로 하면 오용되지 않을 것이라 확신할 수 있다.

### 7.1.5 장점: 타입(형) 검사기는 속성을 보증한다.

- 타입검사는 변수와 멤버가 존재하는지 확인하는 역할
- 프로그래밍 언어의 타입 검사의 강도는 스펙트럼과 같다.
- 우수한 타입 검사기가 있는 언어에서는 프로그램의 속성을 정의하는 것이 우리가 얻을 수 있는 최고 수준의 보안이다.

### 7.1.6 약점: null을 역참조하면 애플리케이션이 손상된다.

- null로 메서드를 호출하려고 하면 오류가 발생하기 때문에 위험하다.
- 일부 도구는 이러한 경우 일부를 감지할 수 있지만, 모든 경우 감지할 수는 없으므로 무작정 도구에 의존할 수는 없다.
- 런타임 오류의 위험은 nullable 변수를 다룰 때 주의필요!

### 7.1.7 약점: 산술 오류는 오버플로나 손상을 일으킨다.

- 산술 연산을 할 때 컴파일러는 큰 도움이 되지 않기 때문에 매우 주의

### 7.1.8 약점: 아웃-오브-바운드 오류는 애플리케이션을 손상시킨다.

- 직접 데이터 구조에 접근할 때 아웃오브바운드 오류가 발생
- 기대하는 요소를 찾지 못할 위험이 있는 경우 전체 데이터 구조를 탐색하거나 요소가 확실하게 있음을 증명하기 위해 확정 할당의 접근 방식을 사용하면 해결 가능

### 7.1.9 무한루프는 애플리케이션을 지연시킨다.

### 7.1.10 약점: 교착 상태 및 경쟁 상태로 인해 의도하지 않은 동작이 발생한다.

- 레이스 컨디션은 두 개 이상의 스레드가 공유하는 변수를 읽고 쓰기위해 경쟁할 때 발생하며 두 스레드가 업데이트를 위해 동시에 동일한 값을 읽을 때 발생
- lock을 통해 해결
- 데드락 - 두 스레드가 모두 잠겨있고 진행을 위해 잠금 해제를 기다리는 경우
- 기아 상태 - 한쪽이 계속 실행되어 다른쪽이 실행할 수 없는 상황

## 7.2 컴파일러 사용

- 프로그래밍은 건축이 아닌 문학과 많은 공통점을 지닌다.
  - 컴퓨터에게 지시하며 의사소통한다.
  - 다른 개발자들과 코드로 의사소통한다.
  - 컴파일러와 의사소통한다.

### 7.2.1 컴파일러 활용

- 컴파일러를 TODO리스트로 사용해 안전성을 확보
- 순서 강제화를 이용한 안전성 확보
- 캡슐화 강제를 통한 안전성 확보
- 컴파일러로 사용하지 않는 코드 감지
- 확정 값을 통한 안전성 확보
  - 타입스크립트에서 class 생성자 파라미터에 readonly를 붙일 경우 자동으로 초기화되며 readonly 필드를 초기화하지 않을 경우 컴파일 에러가 발생함.

### 7.2.2 컴파일러와 싸우지 말 것

**타입**

- 타입 검사기는 컴파일러의 가장 강력한 부분으로 속이거나 무력화하는 것은 최악의 선택이다.

**형 변환**

- 형 변환은 컴파일러가 사용자를 돕지 못하게 하고 기볹적으로 특정 변수나 표현식에 대해 비활성화한다.
- 형 변환이 필요하다는 것은 관련된 어디선가 타입에 대해 이해하지 못하고 있다는 말이다.

**동적 타입**

- 타입 검사를 방해하는 것보다 더 나쁜 것은 실제로 타입 검사기를 비활성화 하는 것
- any 사용

**런타임 타입**

- 런타임으로 판단에 필요한 정보를 옮기는 것

**게으름**

- 코드를 만들 때 게으른 것은 단기적인 해결책일뿐이다.

**기본값**

- 기본값을 사용하는 대신 개발자가 무언가를 추가하거나 변경할 때마다 직접 처리하게 하라.

**상속**

- 상속은 구현 클래스 간의 결합을 가져온다.

**처리를 강제하지 않은 예외**

**아키텍처**

- 마이크로 아키텍처에 대한 이해가 필요?
- 마이크로 아키텍처는 팀에 영향을 미치지만 다른 팀에는 영향을 주지 않는 아키텍처

## 7.3 컴파일러 신뢰하기

- 컴파일러보다 우리가 더 잘 알고 있다는 비생산적인 생각에서 벗아나자

### 7.3.1 컴파일러에게 불변속성 가르치기

- 지역 불변속성은 범위가 제한적이고 명확하기 때문에 관리하기 쉽다. 하지만 컴파일러는 충돌이 발생한다.

### 7.3.2 컴파일러의 경고에 주의를 기울일 것

- 경고를 무시할 때 마다 그 이후로 조금씩 주의를 덜 기울이게 된다.

## 7.4 컴파일러만 신뢰할 것

- 컴파일러에게 프로그램의 도메인 구조와 불변속성을 가르치고 경고가 존재하지 않는 출력 결과에 익숙해진다면 성공적인 컴파일은 단순히 코드를 읽어서 얻을 수 있었던 것보다 더 많은 확신을 줄 것이다.
- 컴파일러는 코드가 우리가 예상하는 문제를 해결할지 여부는 알 수 없지만, 우리가 생각하지 못한 이유로 프로그램이 손상될 수 있는지 여부는 알려줄 수 있다.
