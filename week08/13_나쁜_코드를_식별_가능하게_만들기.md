# 나쁜 코드를 식별 가능하게 만들기

- 안티 리팩터링 - 나쁜 코드를 딱 봐도 안 좋아 보이게 만들어서 품질의 수준을 명확히 표시하는 방법

## 13.1 나쁜 코드에 대처하는 자세

- 끔찍하지만 않게 개선하는 것은 실수다.
- 나쁜 코드를 그대로 남겨두면 다시 찾기가 쉽고 통제가 지속 가능하지 않다는 신호를 준다. 신호를 전달하는 메신저로 우리가 비난 받지 않을 거라는 믿음이 있어야 한다.
- 결국 덜 나쁜 코드는 나쁘다는 인식이 명확하게 되지 않기 때문에 나쁜 채로 남겨두면 나쁜 걸 명확하게 알아 추후 확실하게 수정할 날이 온다.

## 13.2 깨끗한 코드와 레거시 코드로 분리

- 나쁜 코드는 그대로 둬서 깨끗한 코드와 레거시 코드의 분리를 명확하게 하자
- 리팩터링은 종종 계단식이다. 일부 코드를 좋게 만들려면 주변 코드도 좋게 만들어야한다.
- 주변 코드가 이미 양호하다면 토끼 굴을 리팩터링할 위험이 낮다.

### 13.2.1 깨진 유리창 이론

- 완전히 맞지는 않지만 한 번 더러워진 코드는 이후의 코드 작성도 더럽게 될 가능성이 높다.

## 13.3 나쁜 코드를 찾는 방법

- 코드를 보고 좋은지 아닌지 판단하는 완벽한 방법은 존재하지 않는다.
- 가독성은 좋은 코드의 한 특징이고 주관적이기 때문이다. 그러나 코드가 나쁜지 추정하는 몇 가지 방법이 있다.

### 13.3.1 이 책의 규칙: 단순하고 구체적인 코드

- 앞에서 얘기한 규칙들
- 다른 곳에 집중하고 경험이나 연습이 없을 때도 눈길을 끌도록 설계
- 다섯 줄 제한, if문은 함수 시작에만 배치 등

### 13.3.2 코드 스멜: 완전하고 추상적인 코드

- 대부분의 코드 스멜은 꽤 많은 연습을 해야 감각을 키울 수 있다.

### 13.3.3 순환 복잡도: 알고리즘(객관적)

- 컴퓨터가 나쁜 코드를 찾아내게 하려는 시도도 있다.
- 순환 복잡도는 코드를 통과하는 경로의 수를 계산한다.
- 조건문, 반복문 등은 두 개의 경로를 제공한다. 코드를 통해 각 경로에 대해 최소한 하나의 테스트가 존재해야 하므로 얼마나 많은 테스트를 해야 하는지에 대한 하한 값을 제공한다.

### 13.3.4 인지 복잡도: 알고리즘(주관적)

- 메서드를 읽는 동안 얼마나 많은 정보를 유지해야 하는지를 측정
- 사람이 통과하는 각 조건을 기억해야 하기 때문에 이것은 순환적 복잡도보다는 중첩을 찾거나 다루는 경향이 있다.
- 인지 복잡도는 사람이 무언가를 읽는 것이 얼마나 어려운지에 더 가까운 추정치

## 13.4 코드를 안전하게 나쁜 코드로 보이기 위한 규칙

- 나쁜 코드를 나쁘게 보이게 할 때, 세 가지 규칙을 따라야 한다.
  1. 올바른 정보를 절대 훼손하지 말 것
  2. 향후 리팩터링을 어렵게 만들지 말 것
  3. 결과를 한눈에 알 수 있을 것
- 정보가 정확하다는 전제하에 기존에 있는 모든 정보를 보존해야 한다.
- 리팩터링을 자신이 하게 될 수 있다는 생각으로 다음 사람을 위해 작업이 불편하게 만들지 않아야 한다는 것이다.
- 결과 코드를 한눈에 알 수 있어야 한다.
