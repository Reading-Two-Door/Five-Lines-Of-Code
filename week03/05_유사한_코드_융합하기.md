# 유사한 코드 융합하기

## 5.1 유사한 클래스 통합하기

- 상수 메서드 - 상수를 반환하는 메서드
- 경우에 따라 다른 값을 반환하는 상수 메서드를 공유하는 클래스는 합칠 수 있다.

` isFallingStone과 moveHorizontal만 다르다. isFalling 값을 constructor 생성자의 매개변수로 사용한다. 그러면 moveHorizontal이 "if문에서 else를 사용하지 말 것" 규칙을 위반하게 되는데 "클래스로 타입 코드 대체" 리팩터링 패턴을 사용해 boolean값을 클래스로 숨기고 메서드 인라인화를 위해 "클래스로의 코드 이관"을 사용 이후 "삭제 후 컴파일하기" 패턴으로 유사 클래스 통합`

### 5.1.1 리팩터링 패턴: 유사 클래스 통합

- 상수 메서드를 공통으로 가진 두 개 이상의 클래스에서 상수 메서드가 클래스에 따라 다른 값을 반환할 때 사용할 수 있는 리팩터링 패턴
- 상수 메서드 집합을 기준(basis)라 한다. 일련의 상수 메서드가 두 개일 때 두 개의 접점을 가진 기준
- 클래스의 수가 적어진다는 것은 일반적으로 더 많은 구조를 발견했다는 것을 의미

## 5.2 단순한 조건 통합하기

- 모든 코드를 이해해야 하는 경우 리팩터링 비용이 많이 든다. 코드를 연구하지 않고도 일부 리팩터링 패턴의 수행이 가능하다는 사실은 상당한 시간을 절약해준다.

### 5.2.1 리팩터링 패턴: if문 결합

- 내용이 동일한 연속적인 if문을 결합해서 중복을 제거

## 5.3 복잡한 조건 통합하기

### 5.3.1 조건을 위한 산술 규칙 사용

- || 는 +(더하기) 처럼 동작하고 && 은 \*(곱하기) 처럼 동작

### 5.3.2 규칙: 순수 조건 사용

- 조건은 항상 순수 조건이여야 한다.
- 부수적인 동작이 존재하는 조건으로 인해 if문 통합을 사용할 수 없다.
- 부수적인 동작은 조건문에서 흔하게 사용하지 않기 때문에 예상할 수 없기에 추적하는 데 시간과 노력을 투자해야 한다.

- 부수적인 동작을 하는 메서드를 분리하여 실직적인 조건은 순수하게 구현
- 부수적인 동작에서 리턴을 분리할 수 없을 경우 캐시를 사용

- 명령에서 질의 분리 - CQRS 패턴
- 명령은 부수효과가 있고 질의는 순수하다. 따라서 void 메서드에서만 부수적인 동작을 허용
- 데이터를 가져오는 것과 변경하는 것을 분리하는 것으로 코드를 더 깔끔하고 예측 가능하게 만든다.

### 5.3.3 조건 산술 적용

- 조건을 수학 방적식으로 변환하고 단순화한 후 다시 코드로 변환
- 괄호로 잘못 묶은 조건의 까다로운 오류를 찾는데도 도움이 된다.

## 5.4 클래스 간의 코드 통합

- 클래스로의 코드 이관 패턴 적용 이후 인라인 메서드화

### 5.4.1 클래스 관계를 묘사하기 위한 UML 클래스 다이어그램 소개

- UML은 코드에 대한 속성을 전달하기 위해 다양한 유형의 표준 다이어그램으로 구성
- 클래스 다이어그램은 인터페이스와 클래스의 구조 관계를 보여준다.

### 5.4.2 리팩터링 패턴: 전략 패턴의 도입

- 다른 클래스를 인스턴스화해서 변형을 도입하는 개념
- 전략이 필드를 가지고 있는 경우 이를 상태 패턴이라고 한다.
- 전략 클래스가 완료된 후 메서드를 추가하는 경우는 거의 없다. 대신 기능을 변경해야 하는 경우 새로운 클래스를 만드는 것을 선호

**전략패턴 도입 상황**

- 코드에 변형을 도입하고 싶어서 리팩토링을 수행하는 경우
- 떨어지는 성질(falling 관련)을 코드화했던 상황에서 변형의 추가가 필요하다고 예상하지 않았을 때?

> 전략 패턴 VS 상태 패턴
>
> 전략 패턴:
>
> - 포트-어댑터 패턴과 비슷하게 인터페이스를 통한 느슨한 결합이 핵심
> - 각 전략(구현체)은 완전히 독립적이고 서로 알 필요가 없음
> - 예시:
>   - 다양한 결제 방식 (신용카드, 페이팔, 계좌이체 등)
>   - 다양한 정렬 알고리즘 (퀵소트, 버블소트, 머지소트 등)
>   - 다양한 로깅 방식 (파일, 콘솔, DB 등)
>
> 상태 패턴:
>
> - 상태 간의 전이(transition)와 그에 따른 행동 변화가 핵심
> - 각 상태는 다음으로 전이 가능한 상태들을 알고 있어야 함
> - 이전 상태가 다음 상태에 영향을 미침
> - 예시:
>   - 주문 처리 (접수 → 처리중 → 배송중 → 배송완료)
>   - 게임 캐릭터 상태 (대기 → 걷기 → 뛰기 → 점프)
>   - 문서 처리 (초안 → 검토중 → 승인 → 발행)

### 5.4.3 규칙: 구현체가 하나뿐인 인터페이스를 만들지 말 것

- 구현 클래스가 하나밖에 없는 인터페이스는 가독성에 도움이 되지 않는다.
- 불필요한 코드의 보일러플레이트를 제한하자
- 인터페이스가 바람직하다고 배우지만 애플리케이션의 크기를 부풀리는 경향을 고려하자

### 5.4.4 리팩터링 패턴: 구현에서 인터페이스 추출

- 인터페이스를 만드는 것을 필요할 때 까지 연기할 수 있다.

## 5.5 유사 함수 통합하기

- 함수 내 다른 부분을 전략패턴을 사용해 class의 메서드로 호출하게 끔 수정

## 5.6 유사한 코드 통합하기

- 유사한 코드의 다른 부분을 생성자 파라미터로 적용
- boolean 값으로 사용되던 값에 추가적인 값이 필요한 경우 number 같은 다른 타입으로 변형
