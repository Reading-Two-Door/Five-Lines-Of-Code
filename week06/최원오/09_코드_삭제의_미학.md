# 코드 삭제의 미학

- 코드에 너무 집착하면 원래 문제에서 초점을 잃고 결국 문제를 수동으로 해결하는 데 걸리는 것보다 문제를 자동화하는 데 더 많은 시간을 소비하게 된다.

## 9.1 다음 시대는 코드를 지우는 시대일 것이다

- 시스템은 너무 크고 복잡해서 아무도 합리적으로 완전히 이해할 수 없다. 이 경우 제거할 수 있는 코드를 파악하려면 실행 중인 코드, 실행 빈도 및 버전을 결정하는 데 시간을 투자해야 하기 때문에 제거하기 쉽지 않다.

## 9.2 복잡성을 제거하기 위한 코드 삭제

- 도메인 복잡성 - 도메인이 기본적으로 가지고 있는 것으로 해결하고 있는 문제는 본질적으로 복잡하다.
- 부수적 복잡성 - 도메인에서 요구하지 않았지만 우연히 추가된 모든 복잡성

### 9.2.1 경험 부족으로 인한 기술적 무지

- 몰라서 불필요한 결합을 추가하지 않고도 문제를 해결할 수 있는 기술이 부족해서 발생
- 의도적 연습을 통해 기술을 향상 시켜야한다. 연습을 대신할 수 있는 것은 없다.

### 9.2.2 시간 압박으로 인한 기술적 낭비

- 시간 압박으로 테스트나 리팩터링을 건너뛰거나 기한을 맞추기 위해 프로세스를 우회하는 등 외부 압력으로 인해 더 나은 지식을 거스르는 방향을 선택
- 모범 사례를 건너뛰지 말자! 압박을 받더라도 관행을 고수하자

### 9.2.3 환경에 따른 기술적 부채

- 기술 부채는 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것, 이 역시 의도적인 결정이지만 중요한 것은 일시적이라는 것이다.
- 기술 부채를 발생시키는 것은 전략적인 결정이며, 만료일이 있는 한 본질적으로 잘못된 것이 없다

### 9.2.4 성장에 따른 기술적 장애물

- 테스트 코드는 느리고 안정적인 것을 선호하는 경우 나쁘지 않으나, 높은 수준의 실험이 도움이 되는 상황에서는 좋지 않다.
- 문서는 무언가를 변경할 때 반드시 업데이트해야 하기 때문에 개발 속도를 늦춘다.
- 변경 사항이 나머지 애플리케이션에 영향을 미칠지 고려해야하고 유지보수 비용이 들기 때문에 코드 자체도 기술적 장애물이다.
- 조금이라도 사용되지 않는 것은 삭제해야한다.

## 9.3 친밀도에 따른 코드 분류

- 최근에 개발한 코드, 자주사용하는 라이브러리와 유틸리티에 익숙하다. 그 외의 것은 배워야 하기에 유지보수 비용이 많이 든다.
- 자주 사용하는 것이 알지 못하는 곳에서 부패하는 것을 막는 유일한 방법이다. 하지만 삭제에 들어가는 비용을 따지면 익숙한 코드를 삭제하는 것이 이해를 먼저 해야하는 코드를 삭제하는 것 보다 저렴하고 안전하다.

## 9.4 레거시 시스템에서의 코드 삭제

- 레거시 코드는 수정하기 겁나는 코드다.
- 개발이 멈추면 안되기 때문에 서비스 팩터의 지표를 높게 유지해서 위험을 최소화할 필요가 있다.
- 생산성을 위해 코드에 익숙해질 필요가 있으며 코드에 대한 책임을 질 필요가 있는데, 코드를 알 수 없는 경우에 그럴 수가 없다.

### 9.4.1 스트랭글러 무화과나무 패턴

- 레거시 코드가 얼마나 사용되고 있는지 확인 후 사용되지 않는 경우 추가 조사 없이 제거 가능
- 레거시 코드에 대한 통찰력을 얻으려면 각 부분이 얼마나 호출되고 호출이 성공했는지도 알아야 한다.
- 레거시 로직을 새로운 패키지 및 네임스페이스에 캡슐화한 다음 새로운 패키지에 게이트 클래스를 만들어 접점을 파악하고 로그를 달아 모니터링 후 사용하지 않는 기능은 유지보수 하지 않기

### 9.4.2 코드 개선을 위한 스트랭글러 무화과나무 패턴 사용

- 가장 많이 호출되는 부분은 마이그레이션이 거의 확실하고, 가장 적게 호출되는 부분은 높은 확률로 삭제될 수 있다.
- 레거시 코드를 리팩터링해서 결합과 취약성을 제거하고 코드를 최신으로 분류 또는 해당 부분을 다시 만들고 게이트를 변경해서 새 버전으로 전환
- 일부 레거시 코드가 중요하지 않고 전략적이지 않은 경우 게이트에서 메서드를 삭제한다.

## 9.5 동결된 프로젝트에서 코드 삭제

- 동결된 프로젝트는 코드에 국한되지 않고 DB 테이블, 통합, 서비스 등이 포함될 수 있다.
- 작성자가 프로젝트에 대해 잊어버리면 프로젝트가 존재하는지조차 알아채기가 불가능할 수 있다.
- 코드에는 사용되지 않는다는 표시가 없기에 변경할 때마다 고려하고 유지해야하므로 정신적 오버헤드를 가중시킨다.

### 9.5.1 바람직한 결과를 기본값으로 설정

- 코드베이스 내부의 경우 메인 브랜치에서 코드를 되돌리고 별도의 브랜치에 넣을 수 있다. 그 다음 태그를 지정하고 6주 후에 태그를 삭제한다고 메모를 작성하여 6주 안에 프로젝트를 사용하지 않으면 그것은 제거될 것이라고 나타낼 수 있다.
- 코드 외적인 경우 제거할 모든 구성 요소를 프로젝트 관리 도구에 기록해두고 티켓을 6주 후로 예약한다.
- 위 시나리오에서는 실수로 기술적 장애물을 추가할 수 없고 사람의 판단에 의해서만 추가될 수 있다.

### 9.5.2 스파이크와 스태빌라이즈(안정화)로 낭비 줄이기

- 프로젝트의 품질에 노력을 기울이지 않고 6주 뒤 많이 사용된 코드라면 고품질로 재구현한다. 그렇지 않다면 삭제

## 9.6 버전 관리에서 브랜치 삭제

- 축적되는 브랜치는 PR 병합 후 브랜치 삭제를 잊거나 실험용 브랜치를 제거하는 것을 잊는 단순한 실수 또는 언젠가는 코드가 필요할 수 있다고 생각해서 동결된 프로젝트의 경우가 있다.
- 더 어려운 유형의 브랜치는 보류 중이지만 통합 과정을 통과하지 못해 차단된 브랜치다.
- 브랜치는 기술적으로는 거의 무료지만 정신적 오버헤드 측면에서는 비용이 많이 든다.
- 메인, 릴리스 브랜치만 상시 운용

### 9.6.1 브랜치 제한으로 낭비 최소화

- 칸반은 진행 중인 작업 제한 개념을 사용한다. 팀이 진행할 수 있는 티켓 수에 상한선 정함으로써 개발에서의 병목현상을 노출하는 데 도움이 된다.
- 너무 많은 브랜치의 문제는 병목현상 문제와 정확히 맞아떨어지기 때문에 동일한 해결책을 사용할 수 있다.

## 9.7 코드 문서 삭제

- 문서는 **관련성, 정확성, 발견 가능성** 3가지 속성 중 하나라도 누락되면 문서의 가치가 크게 떨어진다.

### 9.7.1 지식을 문서화하는 방법을 결정하는 알고리즘

- 문서화하는 것이 의미가 있는지 여부를 결정하는 절차
  1. 문서화 대상이 자주 바뀌면 문서화해서 얻을 수 있는 것이 없다.
  2. 드물게 사용하는 경우 문서화한다.
  3. 그렇지 않고, 자동화할 수 있으면 자동화한디.
  4. 그렇지 않으면 외워라.

## 9.8 테스트 코드 삭제

- 테스트는 다양한 형태로 제공되며 문서보다 더 많은 속성을 가지고 있다.

### 9.8.1 낙관적 테스트 삭제

- 실패할 수 없는 테스트는 가치가 없다.
- 실패한 적이 없는 테스트를 신뢰하지 마라.
- 문제를 바로잡기 전에 테스트를 만들면 요건을 만족하는지 여부를 알 수 있지만, 바로잡은 후 테스트를 만들면 항상 통과한느 것만 볼 뿐이다.

### 9.8.2 비관적 테스트 삭제

- 항상 실패하는 테스트를 한다면 테스트에서 오류가 발견되더라도 피로를 느껴 중대한 오류를 놓칠 위험이 있다.

### 9.8.3 불안정 테스트 수정 또는 삭제

- 항상 같은 결과를 내지 않는 예측할 수 없는 테스트로 어떤 조치도 끌어내지 않는다.

### 9.8.4 복잡한 테스트를 제거하기 위한 코드 리팩터링

- 테스트 코드가 복잡하면 코드의 문제인지 테스트의 문제인지 알기 어렵다.
- 모든 리팩터링 노력은 테스트가 아닌 코드에 집중되야 한다.

### 9.8.5 속도를 높이는 테스트 문화

- 어떤 테스트들이 다른 테스트를 덜 자주 실행하게 만든다면 개발에 지장을 주므로 해결이 필요하다.
- 느린 테스트와 빠른 테스트를 분리하고 가능한 빠른 테스트를 지속적으로 실행하거나 느린 테스트의 실패 원인을 관찰하고 관련이 없는 경우 제거하는 것
- 위치에 대한 테스트를 따로 진행하여 오류를 더 빨리 수정

## 9.9 설정 코드 삭제

- 코드베이스를 늘리지 않고도 사용자 수를 늘릴 수 있을 때 설정성은 소프트웨어의 유용성을 높일 수 있다.
- 설정성을 추가할 때마다 코드의 복잡성이 증가한다.

### 9.9.1 설정의 예상 수명으로 범위 지정

**실험을 위한 설정**

- 설정을 통해 일부 사용자는 변경 사항을 경험할 수 있지만 다른 사용자는 그렇지 않다. (피처 플래그)
- 모든 사용자에게 영향을 주지 않고 피드백을 적용하거나 변경 사항을 선택적으로 해제할 수 있다.
- 무엇이 실험을 위한 설정인지를 처음부터 결정하고 테스트가 완료되는 즉시 제거하라는 알람을 생성해야 한다.

**과도기적인 설정**

- 비지니스 또는 코드베이스가 중요 변경 사항을 겪고 있는 동안 유용
- 많은 유형의 전환이 사용자에게는 잘 보이지 않는다. 즉, 설정을 코드 외부가 아닌 코드 내부에 코드의 일부로 포함시킨다.
- 전환이 완료되고 오래된 부분을 제거할 수 있는 위치가 있다.

**영구적인 설정**

- 사용량을 증가시키거나 유지보수가 간편해야 하기 떄문에 특별하다.
- 사용량이 증가하지 않고 유지보수가 간단하지 않은 경우 비용 가치가 없으므로 제거해야한다.

## 9.10 라이브러리 제거를 위한 코드 삭제

- 라이브러리의 코드를 유지보수할 필요는 없지만 버전에 따라 코드를 수정해야 한다.
- 라이브러리가 의존하는 의존성에 대해서도 걱정해야 한다.

### 9.10.1 외부 라이브러리에 대한 의존도 제한

- 고품질을 공급하는 업체의 라이브러리를 선택해서 해당 업체의 내부 품질 및 보안 요건을 믿는 것
- 라이브러리가 개선 용도인지 중요 용도인지를 분류하여 궁극적으로 라이브러리에 대한 의존을 줄이자

## 9.11 작동 중인 기능에서 코드 삭제

- 코드 비용과 기능 이점의 균형을 조정할 때는 얼마나 오랫동안 복잡성의 증가를 받아들일지, 어떻게 예측 가능성을 평가할지, 어떻게 새로운 기능을 테스트할지, 사람들을 얼마나 잘 참여시키는지 등등 많은 요소가 작용한다.
- 사용되지 않는 것은 잠재력과 상관없이 비용일 뿐이다.
