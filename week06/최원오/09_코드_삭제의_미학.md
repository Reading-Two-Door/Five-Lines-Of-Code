# 코드 삭제의 미학

- 코드에 너무 집착하면 원래 문제에서 초점을 잃고 결국 문제를 수동으로 해결하는 데 걸리는 것보다 문제를 자동화하는 데 더 많은 시간을 소비하게 된다.

## 9.1 다음 시대는 코드를 지우는 시대일 것이다

- 시스템은 너무 크고 복잡해서 아무도 합리적으로 완전히 이해할 수 없다. 이 경우 제거할 수 있는 코드를 파악하려면 실행 중인 코드, 실행 빈도 및 버전을 결정하는 데 시간을 투자해야 하기 때문에 제거하기 쉽지 않다.

## 9.2 복잡성을 제거하기 위한 코드 삭제

- 도메인 복잡성 - 도메인이 기본적으로 가지고 있는 것으로 해결하고 있는 문제는 본질적으로 복잡하다.
- 부수적 복잡성 - 도메인에서 요구하지 않았지만 우연히 추가된 모든 복잡성

### 9.2.1 경험 부족으로 인한 기술적 무지

- 몰라서 불필요한 결합을 추가하지 않고도 문제를 해결할 수 있는 기술이 부족해서 발생
- 의도적 연습을 통해 기술을 향상 시켜야한다. 연습을 대신할 수 있는 것은 없다.

### 9.2.2 시간 압박으로 인한 기술적 낭비

- 시간 압박으로 테스트나 리팩터링을 건너뛰거나 기한을 맞추기 위해 프로세스를 우회하는 등 외부 압력으로 인해 더 나은 지식을 거스르는 방향을 선택
- 모범 사례를 건너뛰지 말자! 압박을 받더라도 관행을 고수하자

### 9.2.3 환경에 따른 기술적 부채

- 기술 부채는 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것, 이 역시 의도적인 결정이지만 중요한 것은 일시적이라는 것이다.
- 기술 부채를 발생시키는 것은 전략적인 결정이며, 만료일이 있는 한 본질적으로 잘못된 것이 없다

### 9.2.4 성장에 따른 기술적 장애물

- 테스트 코드는 느리고 안정적인 것을 선호하는 경우 나쁘지 않으나, 높은 수준의 실험이 도움이 되는 상황에서는 좋지 않다.
- 문서는 무언가를 변경할 때 반드시 업데이트해야 하기 때문에 개발 속도를 늦춘다.
- 변경 사항이 나머지 애플리케이션에 영향을 미칠지 고려해야하고 유지보수 비용이 들기 때문에 코드 자체도 기술적 장애물이다.
- 조금이라도 사용되지 않는 것은 삭제해야한다.

## 9.3 친밀도에 따른 코드 분류

- 최근에 개발한 코드, 자주사용하는 라이브러리와 유틸리티에 익숙하다. 그 외의 것은 배워야 하기에 유지보수 비용이 많이 든다.
- 자주 사용하는 것이 알지 못하는 곳에서 부패하는 것을 막는 유일한 방법이다. 하지만 삭제에 들어가는 비용을 따지면 익숙한 코드를 삭제하는 것이 이해를 먼저 해야하는 코드를 삭제하는 것 보다 저렴하고 안전하다.

## 9.4 레거시 시스템에서의 코드 삭제

- 레거시 코드는 수정하기 겁나는 코드다.
- 개발이 멈추면 안되기 때문에 서비스 팩터의 지표를 높게 유지해서 위험을 최소화할 필요가 있다.
- 생산성을 위해 코드에 익숙해질 필요가 있으며 코드에 대한 책임을 질 필요가 있는데, 코드를 알 수 없는 경우에 그럴 수가 없다.

### 9.4.1 스트랭글러 무화과나무 패턴

- 레거시 코드가 얼마나 사용되고 있는지 확인 후 사용되지 않는 경우 추가 조사 없이 제거 가능
- 레거시 코드에 대한 통찰력을 얻으려면 각 부분이 얼마나 호출되고 호출이 성공했는지도 알아야 한다.
- 레거시 로직을 새로운 패키지 및 네임스페이스에 캡슐화한 다음 새로운 패키지에 게이트 클래스를 만들어 접점을 파악하고 로그를 달아 모니터링 후 사용하지 않는 기능은 유지보수 하지 않기

### 9.4.2 코드 개선을 위한 스트랭글러 무화과나무 패턴 사용

- 가장 많이 호출되는 부분은 마이그레이션이 거의 확실하고, 가장 적게 호출되는 부분은 높은 확률로 삭제될 수 있다.
- 레거시 코드를 리팩터링해서 결합과 취약성을 제거하고 코드를 최신으로 분류 또는 해당 부분을 다시 만들고 게이트를 변경해서 새 버전으로 전환
- 일부 레거시 코드가 중요하지 않고 전략적이지 않은 경우 게이트에서 메서드를 삭제한다.
